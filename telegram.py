import telebot
from telebot.apihelper import ApiException
import settings
import os
import converter
import twitter_
import re
from util import get_version
from languages import get_string


class TGBot:
    """This is the Telegram Bot class

    Attributes:
        :ivar key: Telegram API key
        :ivar user: Telegram user ID that the bot is linked to
        :ivar bot: The pyTelegramBotAPI bot instance
        :type key: str
        :type user: int
        :type bot: TeleBot
    """

    def __init__(self, cfg: settings.Settings):
        """Inits the bot and tests that the API key is valid.

        :param cfg: configurations class
        :type cfg: Settings
        """
        self.cfg = cfg
        self.tw = twitter_.Twitter(cfg)
        self.key = cfg.telegram_key
        self.user = cfg.telegram_user_id
        self.bot = telebot.TeleBot(self.key)
        self.link_key = None
        try:
            cuentabot = self.bot.get_me()
        except ApiException:
            raise ValueError(get_string("telegram_invalid_key"))
        print(get_string("telegram_connected").format(cuentabot.username))

        @self.bot.message_handler(content_types=['voice', 'audio'])
        def launch_voice(msg):
            self.tg_audio_handler(msg)

        @self.bot.message_handler(func=lambda msg: True)
        def launch_text(msg):
            self.tg_message_handler(msg)

    def tg_audio_handler(self, message: telebot.types.Message):
        """Audio handler

        :param message: message generated by PyTelegramBotAPI
        :return:
        """
        if message.from_user.id == self.user:
            self.send_msg(get_string("voice_received"))
            if message.voice is not None:
                archivo = message.voice
            else:
                archivo = message.audio
            voice_info = self.bot.get_file(archivo.file_id)
            downloaded_voice = self.bot.download_file(voice_info.file_path)
            if not os.path.exists("media"):
                os.makedirs("media")
            filename = "media/" + str(archivo.file_id)
            duration = archivo.duration
            with open(filename + ".ogg", "wb") as file:
                file.write(downloaded_voice)
            try:
                os.remove(filename + ".mp4")
            except:
                pass
            converter.convert(filename, duration)
            try:
                self.tw.tweet(filename + ".mp4")
                self.send_msg(get_string("audio_sent"))
            except KeyError as e:
                self.send_msg(get_string("audio_not_sent"))
            os.remove(filename + ".ogg")
            os.remove(filename + ".mp4")

    def tg_message_handler(self, message: telebot.types.Message):
        """Text message handler

        :param message: message generated by PyTelegramBotAPI
        :return:
        """
        if self.user is None:
            if message.text == self.link_key:
                self.cfg.telegram_user_id = message.from_user.id
                self.user = message.from_user.id
                print(get_string("bot_linked_console").format(message.from_user.id, message.from_user.first_name))
                self.send_msg(get_string("bot_linked_message"))
                self.cfg.save_settings("config.cfg")
        else:
            if message.from_user.id == self.user:
                match = re.search("https://twitter.com/[a-zA-Z0-9_]+/status/[0-9]+", message.text)
                if match is not None:
                    url = message.text[match.start():match.end()]
                    foo, tweet_id = url.rsplit("/", 1)
                    tweet_text, user = self.tw.set_reply(tweet_id)
                    if tweet_text is not None:
                        self.send_msg(get_string("now_replying").format(user, tweet_text))
                    else:
                        self.send_msg(get_string("tweet_doesnt_exist"))
                else:
                    if message.text == "/cancel":
                        self.tw.set_reply(None)
                        self.send_msg(get_string("cancel_reply"))
                    elif message.text.startswith("/text"):
                        if message.text == "/text" or message.text == "/text ":
                            text = ""
                        else:
                            text = message.text[6:]

                        while len(text) > 240:
                            spacestext = " ".join(text.split(" ")[:-1])
                            if spacestext == "":
                                # if it has returned an empty string it means the word has no more spaces (safety check)
                                # slice at max and go
                                text = text[:239]
                            else:
                                text = spacestext
                        # check again

                        self.tw.set_text(text)
                        if text == "":
                            self.send_msg(get_string("text_cleared"))
                        else:
                            self.send_msg(get_string("text_set").format(text))
                    elif message.text.startswith("/dm"):
                        if message.text == "/dm" or message.text == "/dm ":
                            user = None
                        else:
                            user = message.text[4:]
                            user = user.replace("@", "")
                        user = self.tw.set_dm_user(user)
                        if user is None:
                            self.send_msg(get_string("dm_cancel"))
                        else:
                            self.send_msg(get_string("sending_dm").format(user))
                    elif message.text == "/help":
                        self.send_msg(get_string("help"))
                    elif message.text == "/about":
                        self.send_msg(get_string("about").format(get_version()), parse_mode="Markdown", disableweb=True)

    def send_msg(self, text: str, parse_mode=None, disableweb=False):
        """Sends a Telegram message to the linked user

        :param text: Text message
        :type text: str
        :return: None
        """
        self.bot.send_message(self.user, text, parse_mode=parse_mode, disable_web_page_preview=disableweb)

    def set_auth_code(self, code):
        self.link_key = code
